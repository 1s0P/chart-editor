<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>4レーン譜面エディタ (内部96分固定)</title>
  <style>
    body { margin: 0; font-family: sans-serif; }
    .toolbar { position: sticky; top: 0; background: #eee; padding: 5px; display: flex; align-items: center; gap: 8px; z-index: 10; }
    .main { display: flex; }
    canvas { background: #fff; cursor: crosshair; }
    .sidebar { width: 220px; padding: 10px; background: #f9f9f9; font-size: 14px; line-height: 1.4; }
    label, select, input, button { font-size: 14px; }

    .mode-bar input[type="radio"] { display: none; }
    .mode-bar label { display: inline-block; border: 2px solid transparent; border-radius: 6px; padding: 2px; margin: 2px; }
    .mode-bar img { width: 32px; height: 32px; cursor: pointer; opacity: .6; transition: opacity .2s; }
    .mode-bar input[type="radio"]:checked + img { opacity: 1; border: 2px solid #4caf50; border-radius: 6px; }

  </style>
</head>
<body>
  <div class="toolbar">
    <div class="mode-bar">
      <label>
        <input type="radio" name="mode" value="tap" checked />
        <img src="icons/Tap.png" alt="Tap" title="Tap (C1–F1)" />
      </label>
      <label>
        <input type="radio" name="mode" value="long" />
        <img src="icons/Hold.png" alt="Hold" title="Hold (C2–F2)" />
      </label>
      <label>
        <input type="radio" name="mode" value="tick" />
        <img src="icons/Tick.png" alt="Tick" title="Tick (C3–F3)" />
      </label>
      <label>
        <input type="radio" name="mode" value="select" />
        <img src="icons/select.png" alt="Select" title="Select/範囲選択" />
      </label>
      <label>
        <input type="radio" name="mode" value="fxTap" />
        <img src="icons/FX_Tap.png" alt="FX Tap" title="FX Tap (C4–F4)" />
      </label>
      <label>
        <input type="radio" name="mode" value="fxLong" />
        <img src="icons/FX_Hold.png" alt="FX Hold" title="FX Hold (C5–F5)" />
      </label>
      <label>
        <input type="radio" name="mode" value="slashfx" />
        <img src="icons/SLASHFX_L.png" alt="SLASH FX" title="SLASH FX (C7/F7) 端レーン限定" />
      </label>
    </div>

    <button id="copyBtn" disabled>コピー</button>
    <button id="pasteBtn" disabled>ペースト</button>
    <button id="mirrorPasteBtn" disabled>左右反転貼り付け</button>
    <button id="deleteBtn" disabled>削除</button>
    <button id="flipBtn" disabled>左右反転</button>

    <label>Placement Unit:
      <select id="unitSelect">
        <option value="16">1/16</option>
        <option value="24">1/24</option>
        <option value="32">1/32</option>
        <option value="48">1/48</option>
        <option value="96">1/96</option>
      </select>
    </label>
    <label>Measures: <input type="number" id="measureCount" value="4" min="1" style="width:50px;" /></label>
    <label>Lane Height: <input type="range" id="laneHeight" min="20" max="60" value="20" /></label>
    <label>BPM: <input type="number" id="bpm" value="120" style="width:60px;" /></label>
    <button id="exportMidi">Export MIDI</button>
    <label>Import MIDI: <input type="file" id="importMidi" accept=".mid" /></label>
  </div>

  <div class="main">
    <canvas id="editor"></canvas>
    <div class="sidebar">
      <strong>操作説明</strong><br>
      • Tap: 左クリックでタップ配置（緑）<br>
      • Hold: 左クリック2回でロング配置（青。4分未満でも可）<br>
      • Tick: 左ドラッグで連続配置（黄色）<br>
      • FX Tap: 赤（仕様はTapと同じ）<br>
      • FX Hold: 赤系ロング（仕様はHoldと同じ）<br>
      • SLASH FX: 左端(C7/赤)・右端(F7/青)のみ配置可、ジグザグ描画<br>
      • Select: 範囲選択→ Copy/Paste/Delete/Flip/Mirror Paste<br>
      • ショートカット: Ctrl+C / Ctrl+V / Delete<br>
      • 右ドラッグ: 消しゴム（Select以外のモードで有効）
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/midi-writer-js/browser/midiwriter.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tonejs/midi/build/Midi.min.js"></script>
  <script>
    const { Track, Writer, NoteEvent } = window.MidiWriter;
    const { Midi } = window;

    const INTERNAL_DIV   = 96;
    const QUARTER_UNITS  = INTERNAL_DIV / 4;  // 24
    const EIGHTH_UNITS   = INTERNAL_DIV / 8;  // 12
    const SIXTEENTH_UNITS= INTERNAL_DIV / 16; // 6

    const canvas = document.getElementById('editor');
    const ctx = canvas.getContext('2d');
    const laneCount = 4;

    let laneHeight   = +document.getElementById('laneHeight').value;
    let measureCount = +document.getElementById('measureCount').value;
    let bpm          = +document.getElementById('bpm').value;
    let mode         = 'tap';
    let unit         = +document.getElementById('unitSelect').value;

    const taps = [];          
    const longNotes = [];     
    const ticks = [];         
    const fxTaps = [];        
    const fxLongNotes = [];   
    const slashFx = [];       

    let pendingLong = null;

   
    let selStart = null, selRect = null, isDragging = false;
    let selectedTaps = [], selectedLong = [], selectedTicks = [];
    let selectedFxTaps = [], selectedFxLong = [], selectedSlash = [];
    let clipTaps = [], clipLong = [], clipTicks = [], clipFxTaps = [], clipFxLong = [], clipSlash = [];
    let clipOrigin = 0;
    let pasteTarget = null;

    let isTickPainting = false;
    let isErasing = false;

    const copyBtn        = document.getElementById('copyBtn');
    const pasteBtn       = document.getElementById('pasteBtn');
    const mirrorPasteBtn = document.getElementById('mirrorPasteBtn');
    const deleteBtn      = document.getElementById('deleteBtn');
    const flipBtn        = document.getElementById('flipBtn');

    
    function mirrorLane(l){ return (laneCount - 1) - l; }
    function getCanvasCoords(evt){ const r=canvas.getBoundingClientRect(); return { x:evt.clientX-r.left, y:evt.clientY-r.top }; }
    function intersects(rx,ry,rw,rh,x,y,w,h){ return !(rx> x+w || rx+rw< x || ry> y+h || ry+rh< y); }
    function snap(raw){ const g=INTERNAL_DIV/unit; return Math.floor(Math.min(INTERNAL_DIV*measureCount-1,Math.max(0,raw))/g)*g; }
    function hasSelection(){
      return selectedTaps.length || selectedLong.length || selectedTicks.length || selectedFxTaps.length || selectedFxLong.length || selectedSlash.length;
    }
    function hasTickAt(measure,lane,time){
      return ticks.some(t => t.measure===measure && t.lane===lane && t.time===time);
    }

    function updateActionButtons(){
      const hasSel  = hasSelection();
      const hasClip = (clipTaps.length || clipLong.length || clipTicks.length || clipFxTaps.length || clipFxLong.length || clipSlash.length);
      const canPasteToPos = hasClip && pasteTarget != null;

      copyBtn.disabled        = !hasSel;
      deleteBtn.disabled      = !hasSel;
      flipBtn.disabled        = !hasSel;
      pasteBtn.disabled       = !canPasteToPos;
      mirrorPasteBtn.disabled = !canPasteToPos;
    }

    function resizeCanvas(){
      canvas.width = 820; 
      const px = laneHeight / (INTERNAL_DIV / 16);
      canvas.height = px * INTERNAL_DIV * measureCount;
    }

   
    function draw(){
      resizeCanvas(); ctx.clearRect(0,0,canvas.width,canvas.height);
      const laneW = canvas.width / laneCount;
      const px = laneHeight / (INTERNAL_DIV / 16);

   
      for(let m=0;m<measureCount;m++){
        const base = canvas.height - m*INTERNAL_DIV*px;
        ctx.strokeStyle = '#888'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(0,base); ctx.lineTo(canvas.width,base); ctx.stroke();
        ctx.fillStyle = '#000'; ctx.font = '12px sans-serif'; ctx.textBaseline='bottom';
        ctx.fillText(m+1,4,base-2);
        for(let i=1;i<INTERNAL_DIV;i++){
          const y = base - i*px;
          if(i % (INTERNAL_DIV/4)===0){ctx.strokeStyle='#bbb'; ctx.lineWidth=1.5;}
          else if(i % (INTERNAL_DIV/16)===0){ctx.strokeStyle='#eee'; ctx.lineWidth=1;}
          else continue;
          ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke();
        }
      }
      ctx.strokeStyle='#888'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(canvas.width,0); ctx.stroke();
      ctx.strokeStyle='#ccc'; ctx.lineWidth=1;
      for(let i=0;i<=laneCount;i++){const x=i*laneW; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke();}

  
      taps.forEach((t,i)=>{
        const pos=t.measure*INTERNAL_DIV + t.time;
        const y=canvas.height - pos*px;
        const x=t.lane*laneW + laneW*0.1;
        ctx.fillStyle = selectedTaps.includes(i)? '#66bb66' : '#228b22';
        ctx.fillRect(x, y-laneHeight*0.2, laneW*0.8, laneHeight*0.4);
      });

   
      longNotes.forEach((ln,i)=>{
        const s=ln.startMeasure*INTERNAL_DIV + ln.startUnit;
        const e=ln.endMeasure*INTERNAL_DIV + ln.endUnit;
        const y1=canvas.height - s*px;
        const y2=canvas.height - e*px;
        const h=(y1 - y2);
        const x=ln.lane*laneW + laneW*0.1;
        ctx.fillStyle = selectedLong.includes(i)? 'rgba(80,160,255,0.6)' : 'rgba(0,0,255,0.3)';
        ctx.fillRect(x, y2, laneW*0.8, h);
      });

   
      ticks.forEach((t,i)=>{
        const pos=t.measure*INTERNAL_DIV + t.time;
        const y=canvas.height - pos*px;
        const x=t.lane*laneW + laneW*0.1;
        ctx.fillStyle = selectedTicks.includes(i)? '#ffe680' : '#ff0';
        ctx.fillRect(x, y-laneHeight*0.2, laneW*0.8, laneHeight*0.4);
        ctx.strokeStyle = 'rgba(0,0,0,0.15)'; ctx.strokeRect(x, y-laneHeight*0.2, laneW*0.8, laneHeight*0.4);
      });


      fxTaps.forEach((t,i)=>{
        const pos=t.measure*INTERNAL_DIV + t.time;
        const y=canvas.height - pos*px;
        const x=t.lane*laneW + laneW*0.1;
        ctx.fillStyle = selectedFxTaps.includes(i)? '#ff8080' : '#ff3333';
        ctx.fillRect(x, y-laneHeight*0.2, laneW*0.8, laneHeight*0.4);
      });

      fxLongNotes.forEach((ln,i)=>{
        const s=ln.startMeasure*INTERNAL_DIV + ln.startUnit;
        const e=ln.endMeasure*INTERNAL_DIV + ln.endUnit;
        const y1=canvas.height - s*px;
        const y2=canvas.height - e*px;
        const h=(y1 - y2);
        const x=ln.lane*laneW + laneW*0.1;
        ctx.fillStyle = selectedFxLong.includes(i)? 'rgba(255,100,100,0.6)' : 'rgba(255,0,100,0.3)';
        ctx.fillRect(x, y2, laneW*0.8, h);
      });
      slashFx.forEach((s,i)=>{
        const pos=s.measure*INTERNAL_DIV + s.time;
        const y=canvas.height - pos*px;
        const x=s.lane*laneW + laneW*0.1;
        const w=laneW*0.8, h=laneHeight*0.4;
      
        ctx.fillStyle = s.color==='red' ? (selectedSlash.includes(i)? '#ff9999':'#ff4444') 
                                        : (selectedSlash.includes(i)? '#99b6ff':'#3366ff');
        ctx.beginPath();
        const steps = 8;
        const dy = h/steps;
        for(let k=0;k<=steps;k++){
          const xx = (k%2===0)? x : (x+w);
          const yy = (y - h/2 + k*dy);
          if(k===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
        }
        ctx.lineTo(x, y+h/2); 
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle='rgba(0,0,0,0.15)'; ctx.stroke();
      });

      if(selRect){
        ctx.strokeStyle='rgba(0,128,0,0.8)'; ctx.lineWidth=1;
        const {x,y,w,h}=selRect; ctx.strokeRect(x,y,w,h);
      }
    }

    function pasteFromClipboard(mirror=false){
      if(pasteTarget==null) return;

      clipTaps.forEach(n=>{
        const rel = n.measure*INTERNAL_DIV + n.time - clipOrigin;
        const g   = pasteTarget + rel;
        taps.push({
          measure: Math.floor(g/INTERNAL_DIV),
          lane:    mirror ? mirrorLane(n.lane) : n.lane,
          time:    g % INTERNAL_DIV
        });
      });

      clipLong.forEach(ln=>{
        const rel = ln.startMeasure*INTERNAL_DIV + ln.startUnit - clipOrigin;
        const g   = pasteTarget + rel;
        const dur = (ln.endMeasure*INTERNAL_DIV + ln.endUnit) - (ln.startMeasure*INTERNAL_DIV + ln.startUnit);
        const g1  = g + dur;
        longNotes.push({
          startMeasure: Math.floor(g/INTERNAL_DIV),
          startUnit:    g % INTERNAL_DIV,
          lane:         mirror ? mirrorLane(ln.lane) : ln.lane,
          endMeasure:   Math.floor(g1/INTERNAL_DIV),
          endUnit:      g1 % INTERNAL_DIV
        });
      });

      clipTicks.forEach(n=>{
        const rel = n.measure*INTERNAL_DIV + n.time - clipOrigin;
        const g   = pasteTarget + rel;
        const m = Math.floor(g/INTERNAL_DIV);
        const u = g % INTERNAL_DIV;
        const lane = mirror ? mirrorLane(n.lane) : n.lane;
        if(!hasTickAt(m,lane,u)) ticks.push({ measure:m, lane, time:u });
      });

      clipFxTaps.forEach(n=>{
        const rel = n.measure*INTERNAL_DIV + n.time - clipOrigin;
        const g   = pasteTarget + rel;
        fxTaps.push({
          measure: Math.floor(g/INTERNAL_DIV),
          lane:    mirror ? mirrorLane(n.lane) : n.lane,
          time:    g % INTERNAL_DIV
        });
      });

      clipFxLong.forEach(ln=>{
        const rel = ln.startMeasure*INTERNAL_DIV + ln.startUnit - clipOrigin;
        const g   = pasteTarget + rel;
        const dur = (ln.endMeasure*INTERNAL_DIV + ln.endUnit) - (ln.startMeasure*INTERNAL_DIV + ln.startUnit);
        const g1  = g + dur;
        fxLongNotes.push({
          startMeasure: Math.floor(g/INTERNAL_DIV),
          startUnit:    g % INTERNAL_DIV,
          lane:         mirror ? mirrorLane(ln.lane) : ln.lane,
          endMeasure:   Math.floor(g1/INTERNAL_DIV),
          endUnit:      g1 % INTERNAL_DIV
        });
      });

      clipSlash.forEach(s=>{
        const rel = s.measure*INTERNAL_DIV + s.time - clipOrigin;
        const g   = pasteTarget + rel;
        const lane = mirror ? mirrorLane(s.lane) : s.lane;
        const color = (lane===0)? 'red' : (lane===3? 'blue' : s.color);
        slashFx.push({
          measure: Math.floor(g/INTERNAL_DIV),
          lane,
          time: g % INTERNAL_DIV,
          color
        });
      });

      draw();
    }

    function flipSelectionLR(){
      if(!hasSelection()) return;
      selectedTaps.forEach(i => { taps[i].lane = mirrorLane(taps[i].lane); });
      selectedLong.forEach(i => { longNotes[i].lane = mirrorLane(longNotes[i].lane); });
      selectedTicks.forEach(i => { ticks[i].lane = mirrorLane(ticks[i].lane); });
      selectedFxTaps.forEach(i => { fxTaps[i].lane = mirrorLane(fxTaps[i].lane); });
      selectedFxLong.forEach(i => { fxLongNotes[i].lane = mirrorLane(fxLongNotes[i].lane); });
      selectedSlash.forEach(i => { 
        const s = slashFx[i];
        s.lane = mirrorLane(s.lane);
        s.color = (s.lane===0)? 'red' : (s.lane===3? 'blue' : s.color);
      });
      draw();
    }

    function placeTickAtCoord(coord){
      const pxUnit = (laneHeight/(INTERNAL_DIV/16));
      const raw = (canvas.height - coord.y) / pxUnit;
      const gu = snap(raw);
      const m = Math.floor(gu/INTERNAL_DIV);
      const u = gu%INTERNAL_DIV;
      const lane = Math.floor(coord.x/(canvas.width/laneCount));
      if(m<0 || m>=measureCount) return;
      if(lane<0 || lane>=laneCount) return;
      if(!hasTickAt(m,lane,u)){ ticks.push({ measure:m, lane, time:u }); draw(); }
    }

    function eraseAtCoord(coord){
      const pxUnit = (laneHeight/(INTERNAL_DIV/16));
      const raw = (canvas.height - coord.y) / pxUnit;
      const gu = Math.round(raw);
      const m = Math.floor(gu/INTERNAL_DIV), u = gu%INTERNAL_DIV;
      const lane = Math.floor(coord.x/(canvas.width/laneCount));

      // tap
      let idx=taps.findIndex(t=>t.measure===m&&t.lane===lane&&t.time===u);
      if(idx>=0){ taps.splice(idx,1); draw(); return; }
      // hold
      idx=longNotes.findIndex(ln=>{
        const s=ln.startMeasure*INTERNAL_DIV+ln.startUnit;
        const e=ln.endMeasure*INTERNAL_DIV+ln.endUnit;
        return s<=gu && gu<=e && ln.lane===lane;
      });
      if(idx>=0){ longNotes.splice(idx,1); draw(); return; }
      // tick
      idx=ticks.findIndex(t=>t.measure===m&&t.lane===lane&&t.time===u);
      if(idx>=0){ ticks.splice(idx,1); draw(); return; }
      // fx tap
      idx=fxTaps.findIndex(t=>t.measure===m&&t.lane===lane&&t.time===u);
      if(idx>=0){ fxTaps.splice(idx,1); draw(); return; }
      // fx hold
      idx=fxLongNotes.findIndex(ln=>{
        const s=ln.startMeasure*INTERNAL_DIV+ln.startUnit;
        const e=ln.endMeasure*INTERNAL_DIV+ln.endUnit;
        return s<=gu && gu<=e && ln.lane===lane;
      });
      if(idx>=0){ fxLongNotes.splice(idx,1); draw(); return; }
      idx=slashFx.findIndex(s=> s.measure===m && s.lane===lane && s.time===u);
      if(idx>=0){ slashFx.splice(idx,1); draw(); return; }
    }

    function sanitizeMidiTracks(uint8){
      const arr = uint8 instanceof Uint8Array ? uint8 : new Uint8Array(uint8);
      let i = 0; const out = [];
      const push32 = (n)=> out.push((n>>>24)&255,(n>>>16)&255,(n>>>8)&255,n&255);

      while(i < arr.length){
        const id = String.fromCharCode(arr[i],arr[i+1],arr[i+2],arr[i+3]);
        const len = (arr[i+4]<<24)|(arr[i+5]<<16)|(arr[i+6]<<8)|arr[i+7];
        const bodyStart = i+8, bodyEnd = bodyStart + len;

        if(id !== 'MThd' && id !== 'MTrk'){
          out.push(arr[i],arr[i+1],arr[i+2],arr[i+3]); push32(len);
          for(let k=bodyStart;k<bodyEnd;k++) out.push(arr[k]);
          i = bodyEnd; continue;
        }
        if(id === 'MThd'){
          out.push(0x4D,0x54,0x68,0x64); push32(len);
          for(let k=bodyStart;k<bodyEnd;k++) out.push(arr[k]);
          i = bodyEnd; continue;
        }

        let eotPos = -1;
        for(let k=bodyStart; k<=bodyEnd-3; k++){
          if(arr[k]===0xFF && arr[k+1]===0x2F && arr[k+2]===0x00){ eotPos = k+3; break; }
        }
        const newLen = (eotPos > -1 ? (eotPos - bodyStart) : len);

        out.push(0x4D,0x54,0x72,0x6B); push32(newLen);
        const copyEnd = bodyStart + newLen;
        for(let k=bodyStart;k<copyEnd;k++) out.push(arr[k]);

        i = bodyEnd;
      }
      return new Uint8Array(out);
    }

    window.addEventListener('load', ()=>{
      
      document.querySelectorAll('input[name="mode"]').forEach(e=>e.addEventListener('change',ev=>{
        mode=ev.target.value;
        selRect=null; isDragging=false; isTickPainting=false; isErasing=false;
        selectedTaps=[]; selectedLong=[]; selectedTicks=[];
        selectedFxTaps=[]; selectedFxLong=[]; selectedSlash=[];
        pasteTarget = null; draw(); updateActionButtons();
      }));

      document.getElementById('unitSelect').addEventListener('change',e=>{ unit=+e.target.value; });
      document.getElementById('laneHeight').addEventListener('input',e=>{ laneHeight=+e.target.value; draw(); });
      document.getElementById('measureCount').addEventListener('change',e=>{ measureCount=+e.target.value; draw(); });
      document.getElementById('bpm').addEventListener('change',e=>{ bpm=+e.target.value; });

     
      document.addEventListener('keydown', e=>{
        if(mode==='select' && e.ctrlKey && (e.key==='c' || e.key==='C')){
          if(!copyBtn.disabled){ copyBtn.click(); e.preventDefault(); }
        }
        if(mode==='select' && e.ctrlKey && (e.key==='v' || e.key==='V')){
          if(!pasteBtn.disabled){ pasteBtn.click(); e.preventDefault(); }
        }
        if(mode==='select' && e.key === 'Delete'){
          if(!deleteBtn.disabled){ deleteBtn.click(); e.preventDefault(); }
        }
      });

      copyBtn.onclick = ()=>{
        
        clipTaps  = selectedTaps.map(i=> ({...taps[i]}));
        clipLong  = selectedLong.map(i=> ({...longNotes[i]}));
        clipTicks = selectedTicks.map(i=> ({...ticks[i]}));
        clipFxTaps = selectedFxTaps.map(i=> ({...fxTaps[i]}));
        clipFxLong = selectedFxLong.map(i=> ({...fxLongNotes[i]}));
        clipSlash  = selectedSlash.map(i=> ({...slashFx[i]}));

        if (clipTaps.length || clipLong.length || clipTicks.length || clipFxTaps.length || clipFxLong.length || clipSlash.length) {
          const allG = [
            ...clipTaps.map(t=>t.measure*INTERNAL_DIV+t.time),
            ...clipLong.map(ln=>ln.startMeasure*INTERNAL_DIV+ln.startUnit),
            ...clipTicks.map(t=>t.measure*INTERNAL_DIV+t.time),
            ...clipFxTaps.map(t=>t.measure*INTERNAL_DIV+t.time),
            ...clipFxLong.map(ln=>ln.startMeasure*INTERNAL_DIV+ln.startUnit),
            ...clipSlash.map(s=>s.measure*INTERNAL_DIV+s.time),
          ];
          clipOrigin = Math.min(...allG);
        } else clipOrigin = 0;

        pasteTarget = null;
        updateActionButtons();
      };

      pasteBtn.onclick = ()=>{ pasteFromClipboard(false); updateActionButtons(); };
      mirrorPasteBtn.onclick = ()=>{ pasteFromClipboard(true); updateActionButtons(); };

      deleteBtn.onclick = ()=>{
        selectedTaps.sort((a,b)=>b-a).forEach(i=>taps.splice(i,1));
        selectedLong.sort((a,b)=>b-a).forEach(i=>longNotes.splice(i,1));
        selectedTicks.sort((a,b)=>b-a).forEach(i=>ticks.splice(i,1));
        selectedFxTaps.sort((a,b)=>b-a).forEach(i=>fxTaps.splice(i,1));
        selectedFxLong.sort((a,b)=>b-a).forEach(i=>fxLongNotes.splice(i,1));
        selectedSlash.sort((a,b)=>b-a).forEach(i=>slashFx.splice(i,1));

        selectedTaps=[]; selectedLong=[]; selectedTicks=[];
        selectedFxTaps=[]; selectedFxLong=[]; selectedSlash=[];
        pasteTarget = null; draw(); updateActionButtons();
      };

      flipBtn.onclick = ()=>{ flipSelectionLR(); updateActionButtons(); };

      
      canvas.addEventListener('mousedown',e=>{
        if(e.button===2 && mode!=='select'){
          isErasing = true;
          eraseAtCoord(getCanvasCoords(e));
          e.preventDefault();
          return;
        }
        if(mode==='select'){
          isDragging=true; selStart=getCanvasCoords(e); selRect=null;
          selectedTaps=[]; selectedLong=[]; selectedTicks=[];
          selectedFxTaps=[]; selectedFxLong=[]; selectedSlash=[];
          pasteTarget = null; updateActionButtons();
        }
        if(mode==='tick' && e.button===0){
          isTickPainting = true;
          placeTickAtCoord(getCanvasCoords(e));
        }
      });

      canvas.addEventListener('mousemove',e=>{
        if(isErasing){
          eraseAtCoord(getCanvasCoords(e));
          return;
        }
        if(isDragging && mode==='select'){
          const cur=getCanvasCoords(e);
          const x= Math.min(selStart.x,cur.x), y=Math.min(selStart.y,cur.y);
          const w= Math.abs(cur.x-selStart.x), h=Math.abs(cur.y-selStart.y);
          selRect={x,y,w,h}; draw();
        }
        if(mode==='tick' && isTickPainting && (e.buttons & 1)){
          placeTickAtCoord(getCanvasCoords(e));
        }
      });

      canvas.addEventListener('mouseup',e=>{
        if(e.button===2){ isErasing=false; return; }
        if(isDragging && mode==='select'){
          isDragging=false;
          const laneW=canvas.width/laneCount;
          const px=laneHeight/(INTERNAL_DIV/16);
          if(selRect){
            const {x,y,w,h}=selRect;
          
            taps.forEach((t,i)=>{
              const pos=t.measure*INTERNAL_DIV+t.time;
              const cy=canvas.height-pos*px;
              const cx=t.lane*laneW+laneW*0.1;
              if(intersects(x,y,w,h,cx,cy-laneHeight*0.2,laneW*0.8,laneHeight*0.4)) selectedTaps.push(i);
            });
      
            longNotes.forEach((ln,i)=>{
              const s=ln.startMeasure*INTERNAL_DIV+ln.startUnit;
              const e=ln.endMeasure*INTERNAL_DIV+ln.endUnit;
              const y2=canvas.height-e*px;
              const h2=((ln.startMeasure*INTERNAL_DIV+ln.startUnit)-(ln.endMeasure*INTERNAL_DIV+ln.endUnit))*px*-1;
              const x2=ln.lane*laneW+laneW*0.1;
              if(intersects(x,y,w,h,x2,y2,laneW*0.8,h2)) selectedLong.push(i);
            });
            
            ticks.forEach((t,i)=>{
              const pos=t.measure*INTERNAL_DIV+t.time;
              const cy=canvas.height-pos*px;
              const cx=t.lane*laneW+laneW*0.1;
              if(intersects(x,y,w,h,cx,cy-laneHeight*0.2,laneW*0.8,laneHeight*0.4)) selectedTicks.push(i);
            });
            
            fxTaps.forEach((t,i)=>{
              const pos=t.measure*INTERNAL_DIV+t.time;
              const cy=canvas.height-pos*px;
              const cx=t.lane*laneW+laneW*0.1;
              if(intersects(x,y,w,h,cx,cy-laneHeight*0.2,laneW*0.8,laneHeight*0.4)) selectedFxTaps.push(i);
            });
           
            fxLongNotes.forEach((ln,i)=>{
              const s=ln.startMeasure*INTERNAL_DIV+ln.startUnit;
              const e=ln.endMeasure*INTERNAL_DIV+ln.endUnit;
              const y2=canvas.height-e*px;
              const h2=((ln.startMeasure*INTERNAL_DIV+ln.startUnit)-(ln.endMeasure*INTERNAL_DIV+ln.endUnit))*px*-1;
              const x2=ln.lane*laneW+laneW*0.1;
              if(intersects(x,y,w,h,x2,y2,laneW*0.8,h2)) selectedFxLong.push(i);
            });
          
            slashFx.forEach((s,i)=>{
              const pos=s.measure*INTERNAL_DIV+s.time;
              const cy=canvas.height-pos*px;
              const cx=s.lane*laneW+laneW*0.1;
              if(intersects(x,y,w,h,cx,cy-laneHeight*0.2,laneW*0.8,laneHeight*0.4)) selectedSlash.push(i);
            });
          }
          selRect=null; draw(); updateActionButtons();
        }
        if(mode==='tick' && e.button===0){ isTickPainting = false; }
      });

      canvas.addEventListener('click',e=>{
        const coord=getCanvasCoords(e);
        const raw=(canvas.height-coord.y)/(laneHeight/(INTERNAL_DIV/16));
        const gu=snap(raw);
        const m=Math.floor(gu/INTERNAL_DIV), u=gu%INTERNAL_DIV;
        const lane=Math.floor(coord.x/(canvas.width/laneCount));

        if(mode==='select' && (clipTaps.length||clipLong.length||clipTicks.length||clipFxTaps.length||clipFxLong.length||clipSlash.length)){
          pasteTarget=m*INTERNAL_DIV+u; updateActionButtons();
          return;
        }

        if(mode==='tap'){
          taps.push({measure:m,lane,time:u}); draw();
        } else if(mode==='long'){
          if(pendingLong===null) pendingLong={m,u,lane};
          else{
            const start = pendingLong.m*INTERNAL_DIV + pendingLong.u;
            const end   = m*INTERNAL_DIV + u;
            const dur   = end - start;
            if (dur <= 0) alert('終点は始点より下（時間的に後）にしてください');
            else {
              longNotes.push({
                startMeasure: pendingLong.m, startUnit: pendingLong.u, lane: pendingLong.lane,
                endMeasure: m, endUnit: u
              });
            }
            pendingLong=null; draw();
          }
        } else if(mode==='tick'){
          placeTickAtCoord(coord);
        } else if(mode==='fxTap'){
          fxTaps.push({measure:m,lane,time:u}); draw();
        } else if(mode==='fxLong'){
          if(pendingLong===null) pendingLong={m,u,lane, fx:true};
          else{
            const start = pendingLong.m*INTERNAL_DIV + pendingLong.u;
            const end   = m*INTERNAL_DIV + u;
            const dur   = end - start;
            if (dur <= 0) alert('終点は始点より下（時間的に後）にしてください');
            else {
              fxLongNotes.push({
                startMeasure: pendingLong.m, startUnit: pendingLong.u, lane: pendingLong.lane,
                endMeasure: m, endUnit: u
              });
            }
            pendingLong=null; draw();
          }
        } else if(mode==='slashfx'){
          if(lane!==0 && lane!==3){
            alert('SLASH FX は左右端レーン（0 または 3）にのみ配置できます。');
            return;
          }
          const color = (lane===0) ? 'red' : 'blue';
          slashFx.push({measure:m,lane,time:u,color});
          draw();
        }
      });


      canvas.addEventListener('contextmenu', e=>{
        if(mode!=='select'){ e.preventDefault(); }
      });

document.getElementById('exportMidi').addEventListener('click', () => {
  const track = new Track();
  track.setTempo(bpm);

  const ppq = 128;
  const WHOLE_TICKS = ppq * 4;            
  const toTicks = (units) => Math.max(1, Math.round(units * WHOLE_TICKS / INTERNAL_DIV));

  const quarterTicks = WHOLE_TICKS / 4;   
  const tapTicks     = toTicks(1);        

  taps.forEach(t => {
    const startUnits = t.measure * INTERNAL_DIV + t.time;
    track.addEvent(new NoteEvent({
      pitch: ['C1', 'D1', 'E1', 'F1'][t.lane],
      duration: 'T' + tapTicks,
      startTick: toTicks(startUnits)
    }));
  });

  longNotes.forEach(ln => {
  const s = ln.startMeasure*INTERNAL_DIV + ln.startUnit;
  const e = ln.endMeasure  *INTERNAL_DIV + ln.endUnit;
  const d = e - s;

  let stTick, duTick;
  if (Math.abs(d - EIGHTH_UNITS) <= 1) {
    stTick = toTicks(s + EIGHTH_UNITS);
    duTick = toTicks(EIGHTH_UNITS);
  } else {
    stTick = toTicks(s);
    duTick = toTicks(d + QUARTER_UNITS);
  }

  track.addEvent(new NoteEvent({
    pitch:['C2','D2','E2','F2'][ln.lane],
    duration:'T' + duTick,
    startTick: stTick
  }));
});

  ticks.forEach(t => {
    const pos = t.measure * INTERNAL_DIV + t.time;
    const shifted = pos + EIGHTH_UNITS;
    track.addEvent(new NoteEvent({
      pitch: ['C3','D3','E3','F3'][t.lane],
      duration: 'T' + quarterTicks,           
      startTick: toTicks(shifted)
    }));
  });

  fxTaps.forEach(t => {
    const startUnits = t.measure * INTERNAL_DIV + t.time;
    track.addEvent(new NoteEvent({
      pitch: ['C4', 'D4', 'E4', 'F4'][t.lane],
      duration: 'T' + tapTicks,
      startTick: toTicks(startUnits)
    }));
  });

  fxLongNotes.forEach(ln => {
  const s = ln.startMeasure*INTERNAL_DIV + ln.startUnit;
  const e = ln.endMeasure  *INTERNAL_DIV + ln.endUnit;
  const d = e - s;

  let stTick, duTick;
  if (Math.abs(d - EIGHTH_UNITS) <= 1) {
    stTick = toTicks(s + EIGHTH_UNITS);
    duTick = toTicks(EIGHTH_UNITS);
  } else {
    stTick = toTicks(s);
    duTick = toTicks(d + QUARTER_UNITS);
  }

  track.addEvent(new NoteEvent({
    pitch:['C5','D5','E5','F5'][ln.lane],
    duration:'T' + duTick,
    startTick: stTick
  }));
});

  slashFx.forEach(t => {
    if (t.lane !== 0 && t.lane !== 3) return;
    const startUnits = t.measure * INTERNAL_DIV + t.time;
    const pitch = (t.lane === 0) ? 'C6' : 'F6';
    track.addEvent(new NoteEvent({
      pitch,
      duration: 'T' + tapTicks,
      startTick: toTicks(startUnits)
    }));
  });

  const writer = new Writer([track]);
  const b = writer.buildFile();
  const safe = sanitizeMidiTracks(new Uint8Array(b));
  const blob = new Blob([safe], { type: 'audio/midi' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'chart.mid';
  a.click();
});



document.getElementById('importMidi').addEventListener('change', async e => {
  const file = e.target.files[0]; if(!file) return;
  const buf = await file.arrayBuffer();
  const midi = new Midi(buf);

  taps.length=0; longNotes.length=0; ticks.length=0;
  fxTaps.length=0; fxLongNotes.length=0; slashFx.length=0;

  if (midi.header.tempos && midi.header.tempos.length > 0) {
    bpm = Math.round(midi.header.tempos[0].bpm);
    document.getElementById('bpm').value = bpm;
  }

  const ppq = midi.header?.ppq || 128;
  const WHOLE_TICKS = ppq * 4;
  const toUnits = (ticks) => Math.round(ticks * INTERNAL_DIV / WHOLE_TICKS);

  let maxTick = 0;

  midi.tracks.forEach(track => {
    track.notes.forEach(n => {
      const name = n.name?.charAt(0);
      const lane = ['C','D','E','F'].indexOf(name);
      if (lane < 0) return;
      const oct = parseInt(n.name?.slice(1));
      if (Number.isNaN(oct)) return;

      const startUnits = toUnits(n.ticks);
      const durUnits   = toUnits(n.durationTicks);
      const m = Math.floor(startUnits / INTERNAL_DIV);
      const u = startUnits % INTERNAL_DIV;

      if (oct === 1) {
        taps.push({ measure:m, lane, time:u });
        maxTick = Math.max(maxTick, n.ticks);
      }
      else if (oct === 2) {
  const durUnits = toUnits(n.durationTicks);

  if (Math.abs(durUnits - EIGHTH_UNITS) <= 1) {
    const startUnits = Math.max(0, toUnits(n.ticks) - EIGHTH_UNITS);
    longNotes.push({
      startMeasure: Math.floor(startUnits / INTERNAL_DIV),
      startUnit:    startUnits % INTERNAL_DIV,
      lane,
      endMeasure:   Math.floor((startUnits + EIGHTH_UNITS) / INTERNAL_DIV),
      endUnit:      (startUnits + EIGHTH_UNITS) % INTERNAL_DIV
    });
  } else {
    const startUnits = toUnits(n.ticks);
    const editorDur  = Math.max(1, durUnits - QUARTER_UNITS);
    const endUnits   = startUnits + editorDur;
    longNotes.push({
      startMeasure: Math.floor(startUnits / INTERNAL_DIV),
      startUnit:    startUnits % INTERNAL_DIV,
      lane,
      endMeasure:   Math.floor(endUnits / INTERNAL_DIV),
      endUnit:      endUnits % INTERNAL_DIV
    });
  }
}
      else if (oct === 3) {
        const pos = Math.max(0, startUnits - EIGHTH_UNITS);
        ticks.push({
          measure: Math.floor(pos / INTERNAL_DIV),
          lane,
          time: pos % INTERNAL_DIV
        });
        maxTick = Math.max(maxTick, n.ticks);
      }
      else if (oct === 4) {
        fxTaps.push({ measure:m, lane, time:u });
        maxTick = Math.max(maxTick, n.ticks);
      }
      else if (oct === 5) {
  const durUnits = toUnits(n.durationTicks);

  if (Math.abs(durUnits - EIGHTH_UNITS) <= 1) {
    const startUnits = Math.max(0, toUnits(n.ticks) - EIGHTH_UNITS);
    fxLongNotes.push({
      startMeasure: Math.floor(startUnits / INTERNAL_DIV),
      startUnit:    startUnits % INTERNAL_DIV,
      lane,
      endMeasure:   Math.floor((startUnits + EIGHTH_UNITS) / INTERNAL_DIV),
      endUnit:      (startUnits + EIGHTH_UNITS) % INTERNAL_DIV
    });
  } else {
    const startUnits = toUnits(n.ticks);
    const editorDur  = Math.max(1, durUnits - QUARTER_UNITS);
    const endUnits   = startUnits + editorDur;
    fxLongNotes.push({
      startMeasure: Math.floor(startUnits / INTERNAL_DIV),
      startUnit:    startUnits % INTERNAL_DIV,
      lane,
      endMeasure:   Math.floor(endUnits / INTERNAL_DIV),
      endUnit:      endUnits % INTERNAL_DIV
    });
  }
}
      else if (oct === 6) {
        const isLeft  = (lane === 0) && n.name.startsWith('C');
        const isRight = (lane === 3) && n.name.startsWith('F');
        if (isLeft || isRight) {
          slashFx.push({
            measure: m,
            lane,
            time: u,
            color: (lane === 0) ? 'red' : 'blue'
          });
        }
        maxTick = Math.max(maxTick, n.ticks);
      }
    });
  });

  const totalUnits = toUnits(maxTick);
  measureCount = Math.max(1, Math.ceil(totalUnits / INTERNAL_DIV));
  document.getElementById('measureCount').value = measureCount;

  draw();
});



      draw(); updateActionButtons();
    });
  </script>
</body>
</html>
