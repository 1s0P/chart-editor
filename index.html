<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>4レーン譜面エディタ (内部96分固定)</title>
  <style>
    body { margin: 0; font-family: sans-serif; }
    .toolbar { position: sticky; top: 0; background: #eee; padding: 5px; display: flex; align-items: center; gap: 8px; z-index: 10; }
    .main { display: flex; }
    canvas { background: #fff; cursor: crosshair; }
    .sidebar { width: 200px; padding: 10px; background: #f9f9f9; font-size: 14px; line-height: 1.4; }
    label, select, input, button { font-size: 14px; }
  </style>
</head>
<body>
  <div class="toolbar">
    <label>Mode:
      <label><input type="radio" name="mode" value="tap" checked /> Tap</label>
      <label><input type="radio" name="mode" value="long" /> Long</label>
      <label><input type="radio" name="mode" value="tick" /> Tick</label>
      <label><input type="radio" name="mode" value="select" /> Select</label>
    </label>
    <button id="copyBtn" disabled>コピー</button>
    <button id="pasteBtn" disabled>ペースト</button>
    <button id="mirrorPasteBtn" disabled>左右反転貼り付け</button>
    <button id="deleteBtn" disabled>削除</button>
    <button id="flipBtn" disabled>左右反転</button>
    <label>Placement Unit:
      <select id="unitSelect">
        <option value="16">1/16</option>
        <option value="24">1/24</option>
        <option value="32">1/32</option>
        <option value="48">1/48</option>
        <option value="96">1/96</option>
      </select>
    </label>
    <label>Measures: <input type="number" id="measureCount" value="4" min="1" style="width:50px;" /></label>
    <label>Lane Height: <input type="range" id="laneHeight" min="20" max="60" value="20" /></label>
    <label>BPM: <input type="number" id="bpm" value="120" style="width:60px;" /></label>
    <button id="exportMidi">Export MIDI</button>
    <label>Import MIDI: <input type="file" id="importMidi" accept=".mid" /></label>
  </div>

  <div class="main">
    <canvas id="editor"></canvas>
    <div class="sidebar">
      <strong>操作説明</strong><br>
      • Tap: 左クリックでタップ配置<br>
      • Long: 左クリックでロング配置<br>
      • Tick: <u>左クリック押しっぱ＋スライドで連続配置</u><br>
      • Select: 範囲選択→ボタンから特定の操作を選択可能<br>
      • ショートカット: Ctrl+C(コピー) / Ctrl+V(ペースト) / Delete(削除)<br>
      • 右ドラッグ: 消しゴム(マウスを動かすと複数ノーツ一気に削除可能)
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/midi-writer-js/browser/midiwriter.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tonejs/midi/build/Midi.min.js"></script>
  <script>
    const { Track, Writer, NoteEvent } = window.MidiWriter;
    const { Midi } = window;

    const INTERNAL_DIV = 96;
    const QUARTER_UNITS = INTERNAL_DIV / 4;
    const canvas = document.getElementById('editor');
    const ctx = canvas.getContext('2d');
    const laneCount = 4;

    let laneHeight   = +document.getElementById('laneHeight').value;
    let measureCount = +document.getElementById('measureCount').value;
    let bpm          = +document.getElementById('bpm').value;
    let mode         = 'tap';
    let unit         = +document.getElementById('unitSelect').value;

    const taps = [];
    const longNotes = [];
    const ticks = [];

    let pendingLong = null;

    let selStart = null, selRect = null, isDragging = false;
    let selectedTaps = [], selectedLong = [], selectedTicks = [];
    let clipTaps = [], clipLong = [], clipTicks = [];
    let clipOrigin = 0;
    let pasteTarget = null;

    let isTickPainting = false;

    let isErasing = false;

    const copyBtn        = document.getElementById('copyBtn');
    const pasteBtn       = document.getElementById('pasteBtn');
    const mirrorPasteBtn = document.getElementById('mirrorPasteBtn');
    const deleteBtn      = document.getElementById('deleteBtn');
    const flipBtn        = document.getElementById('flipBtn');

    function mirrorLane(l){ return (laneCount - 1) - l; }
    function hasSelection(){ return selectedTaps.length || selectedLong.length || selectedTicks.length; }
    function hasTickAt(measure,lane,time){
      return ticks.some(t => t.measure===measure && t.lane===lane && t.time===time);
    }
    function getCanvasCoords(evt){ const r=canvas.getBoundingClientRect(); return { x:evt.clientX-r.left, y:evt.clientY-r.top }; }
    function intersects(rx,ry,rw,rh,x,y,w,h){ return !(rx> x+w || rx+rw< x || ry> y+h || ry+rh< y); }
    function snap(raw){ const g=INTERNAL_DIV/unit; return Math.floor(Math.min(INTERNAL_DIV*measureCount-1,Math.max(0,raw))/g)*g; }

    function updateActionButtons(){
      const hasSel  = hasSelection();
      const hasClip = (clipTaps.length || clipLong.length || clipTicks.length);
      const canPasteToPos = hasClip && pasteTarget != null;

      copyBtn.disabled        = !hasSel;
      deleteBtn.disabled      = !hasSel;
      flipBtn.disabled        = !hasSel;
      pasteBtn.disabled       = !canPasteToPos;
      mirrorPasteBtn.disabled = !canPasteToPos;
    }

    function resizeCanvas() {
      canvas.width = 800;
      const px = laneHeight / (INTERNAL_DIV / 16);
      canvas.height = px * INTERNAL_DIV * measureCount;
    }

    function draw() {
      resizeCanvas(); ctx.clearRect(0,0,canvas.width,canvas.height);
      const laneW = canvas.width / laneCount;
      const px = laneHeight / (INTERNAL_DIV / 16);

      for(let m=0;m<measureCount;m++){
        const base = canvas.height - m*INTERNAL_DIV*px;
        ctx.strokeStyle = '#888'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(0,base); ctx.lineTo(canvas.width,base); ctx.stroke();
        ctx.fillStyle = '#000'; ctx.font = '12px sans-serif'; ctx.textBaseline='bottom';
        ctx.fillText(m+1,4,base-2);
        for(let i=1;i<INTERNAL_DIV;i++){
          const y = base - i*px;
          if(i % (INTERNAL_DIV/4)===0){ctx.strokeStyle='#bbb'; ctx.lineWidth=1.5;}
          else if(i % (INTERNAL_DIV/16)===0){ctx.strokeStyle='#eee'; ctx.lineWidth=1;}
          else continue;
          ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke();
        }
      }
      ctx.strokeStyle='#888'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(canvas.width,0); ctx.stroke();
      ctx.strokeStyle='#ccc'; ctx.lineWidth=1;
      for(let i=0;i<=laneCount;i++){const x=i*laneW; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke();}

      taps.forEach((t,i)=>{
        const pos = t.measure*INTERNAL_DIV + t.time;
        const y = canvas.height - pos*px;
        const x = t.lane*laneW + laneW*0.1;
        ctx.fillStyle = selectedTaps.includes(i)? '#f88' : '#f00';
        ctx.fillRect(x, y-laneHeight*0.2, laneW*0.8, laneHeight*0.4);
      });
      longNotes.forEach((ln,i)=>{
        const s = ln.startMeasure*INTERNAL_DIV + ln.startUnit;
        const e = ln.endMeasure*INTERNAL_DIV + ln.endUnit;
        const y1 = canvas.height - s*px;
        const y2 = canvas.height - e*px;
        const height = (y1 - y2);
        const x  = ln.lane*laneW + laneW*0.1;
        ctx.fillStyle = selectedLong.includes(i)? 'rgba(255,0,0,0.5)' : 'rgba(0,0,255,0.3)';
        ctx.fillRect(x, y2, laneW*0.8, height);
      });
      ticks.forEach((t,i)=>{
        const pos = t.measure*INTERNAL_DIV + t.time;
        const y = canvas.height - pos*px;
        const x = t.lane*laneW + laneW*0.1;
        ctx.fillStyle = selectedTicks.includes(i)? '#ffe680' : '#ff0';
        ctx.fillRect(x, y-laneHeight*0.2, laneW*0.8, laneHeight*0.4);
        ctx.strokeStyle = 'rgba(0,0,0,0.15)'; ctx.strokeRect(x, y-laneHeight*0.2, laneW*0.8, laneHeight*0.4);
      });

      if(selRect){ ctx.strokeStyle='rgba(0,128,0,0.8)'; ctx.lineWidth=1;
        const {x,y,w,h}=selRect; ctx.strokeRect(x,y,w,h);
      }
    }

    function pasteFromClipboard(mirror=false){
      if(pasteTarget==null) return;

      clipTaps.forEach(n=>{
        const rel = n.measure*INTERNAL_DIV + n.time - clipOrigin;
        const g   = pasteTarget + rel;
        taps.push({
          measure: Math.floor(g/INTERNAL_DIV),
          lane:    mirror ? mirrorLane(n.lane) : n.lane,
          time:    g % INTERNAL_DIV
        });
      });
      clipLong.forEach(ln=>{
        const rel = ln.startMeasure*INTERNAL_DIV + ln.startUnit - clipOrigin;
        const g   = pasteTarget + rel;
        const dur = (ln.endMeasure*INTERNAL_DIV + ln.endUnit) - (ln.startMeasure*INTERNAL_DIV + ln.startUnit);
        const g1  = g + dur;
        longNotes.push({
          startMeasure: Math.floor(g/INTERNAL_DIV),
          startUnit:    g % INTERNAL_DIV,
          lane:         mirror ? mirrorLane(ln.lane) : ln.lane,
          endMeasure:   Math.floor(g1/INTERNAL_DIV),
          endUnit:      g1 % INTERNAL_DIV
        });
      });
      clipTicks.forEach(n=>{
        const rel = n.measure*INTERNAL_DIV + n.time - clipOrigin;
        const g   = pasteTarget + rel;
        const m = Math.floor(g/INTERNAL_DIV);
        const u = g % INTERNAL_DIV;
        const lane = mirror ? mirrorLane(n.lane) : n.lane;
        if(!hasTickAt(m,lane,u)) ticks.push({ measure:m, lane, time:u });
      });

      draw();
    }

    function flipSelectionLR(){
      if(!hasSelection()) return;
      selectedTaps.forEach(i => { taps[i].lane = mirrorLane(taps[i].lane); });
      selectedLong.forEach(i => { longNotes[i].lane = mirrorLane(longNotes[i].lane); });
      selectedTicks.forEach(i => { ticks[i].lane = mirrorLane(ticks[i].lane); });
      draw();
    }

    function placeTickAtCoord(coord){
      const pxUnit = (laneHeight/(INTERNAL_DIV/16));
      const raw = (canvas.height - coord.y) / pxUnit;
      const gu = snap(raw);
      const m = Math.floor(gu/INTERNAL_DIV);
      const u = gu%INTERNAL_DIV;
      const lane = Math.floor(coord.x/(canvas.width/laneCount));
      if(m<0 || m>=measureCount) return;
      if(lane<0 || lane>=laneCount) return;
      if(!hasTickAt(m,lane,u)){ ticks.push({ measure:m, lane, time:u }); draw(); }
    }

    function eraseAtCoord(coord){
      const pxUnit = (laneHeight/(INTERNAL_DIV/16));
      const raw = (canvas.height - coord.y) / pxUnit;
      const gu = Math.round(raw);
      const m = Math.floor(gu/INTERNAL_DIV), u = gu%INTERNAL_DIV;
      const lane = Math.floor(coord.x/(canvas.width/laneCount));

      let idx=taps.findIndex(t=>t.measure===m&&t.lane===lane&&t.time===u);
      if(idx>=0){ taps.splice(idx,1); draw(); return; }
      idx=longNotes.findIndex(ln=>{
        const s=ln.startMeasure*INTERNAL_DIV+ln.startUnit;
        const e=ln.endMeasure*INTERNAL_DIV+ln.endUnit;
        return s<=gu && gu<=e && ln.lane===lane;
      });
      if(idx>=0){ longNotes.splice(idx,1); draw(); return; }
      // tick
      idx=ticks.findIndex(t=>t.measure===m&&t.lane===lane&&t.time===u);
      if(idx>=0){ ticks.splice(idx,1); draw(); return; }
    }

    window.addEventListener('load', ()=>{
      document.querySelectorAll('input[name="mode"]').forEach(e=>e.addEventListener('change',ev=>{
        mode=ev.target.value; selRect=null; isDragging=false; isTickPainting=false; isErasing=false;
        selectedTaps=[]; selectedLong=[]; selectedTicks=[];
        pasteTarget = null; draw(); updateActionButtons();
      }));
      document.getElementById('unitSelect').addEventListener('change',e=>{ unit=+e.target.value; });
      document.getElementById('laneHeight').addEventListener('input',e=>{ laneHeight=+e.target.value; draw(); });
      document.getElementById('measureCount').addEventListener('change',e=>{ measureCount=+e.target.value; draw(); });
      document.getElementById('bpm').addEventListener('change',e=>{ bpm=+e.target.value; });


      document.addEventListener('keydown', e=>{
        if(mode==='select' && e.ctrlKey && (e.key==='c' || e.key==='C')){
          if(!copyBtn.disabled){ copyBtn.click(); e.preventDefault(); }
        }
        if(mode==='select' && e.ctrlKey && (e.key==='v' || e.key==='V')){
          if(!pasteBtn.disabled){ pasteBtn.click(); e.preventDefault(); }
        }
        if(mode==='select' && e.key === 'Delete'){
          if(!deleteBtn.disabled){ deleteBtn.click(); e.preventDefault(); }
        }
      });

      copyBtn.onclick = ()=>{
        clipTaps  = selectedTaps.map(i=> ({...taps[i]}));
        clipLong  = selectedLong.map(i=> ({...longNotes[i]}));
        clipTicks = selectedTicks.map(i=> ({...ticks[i]}));
        if (clipTaps.length || clipLong.length || clipTicks.length) {
          const allG = [
            ...clipTaps.map(t=>t.measure*INTERNAL_DIV+t.time),
            ...clipLong.map(ln=>ln.startMeasure*INTERNAL_DIV+ln.startUnit),
            ...clipTicks.map(t=>t.measure*INTERNAL_DIV+t.time)
          ];
          clipOrigin = Math.min(...allG);
        } else clipOrigin = 0;
        pasteTarget = null;
        updateActionButtons();
      };
      pasteBtn.onclick = ()=>{ pasteFromClipboard(false); updateActionButtons(); };
      mirrorPasteBtn.onclick = ()=>{ pasteFromClipboard(true); updateActionButtons(); };
      deleteBtn.onclick = ()=>{
        selectedTaps.sort((a,b)=>b-a).forEach(i=>taps.splice(i,1));
        selectedLong.sort((a,b)=>b-a).forEach(i=>longNotes.splice(i,1));
        selectedTicks.sort((a,b)=>b-a).forEach(i=>ticks.splice(i,1));
        selectedTaps=[]; selectedLong=[]; selectedTicks=[];
        pasteTarget = null; draw(); updateActionButtons();
      };
      flipBtn.onclick = ()=>{ flipSelectionLR(); updateActionButtons(); };

      canvas.addEventListener('mousedown',e=>{
        if(e.button===2 && mode!=='select'){
          isErasing = true;
          eraseAtCoord(getCanvasCoords(e));
          e.preventDefault();
          return;
        }
        if(mode==='select'){
          isDragging=true; selStart=getCanvasCoords(e); selRect=null;
          selectedTaps=[]; selectedLong=[]; selectedTicks=[];
          pasteTarget = null; updateActionButtons();
        }
        if(mode==='tick' && e.button===0){
          isTickPainting = true;
          placeTickAtCoord(getCanvasCoords(e));
        }
      });
      canvas.addEventListener('mousemove',e=>{
        if(isErasing){
          eraseAtCoord(getCanvasCoords(e));
          return;
        }
        if(isDragging && mode==='select'){
          const cur=getCanvasCoords(e);
          const x= Math.min(selStart.x,cur.x), y=Math.min(selStart.y,cur.y);
          const w= Math.abs(cur.x-selStart.x), h=Math.abs(cur.y-selStart.y);
          selRect={x,y,w,h}; draw();
        }
        if(mode==='tick' && isTickPainting && (e.buttons & 1)){
          placeTickAtCoord(getCanvasCoords(e));
        }
      });
      canvas.addEventListener('mouseup',e=>{
        if(e.button===2){ isErasing=false; return; }
        if(isDragging && mode==='select'){
          isDragging=false;
          const laneW=canvas.width/laneCount;
          const px=laneHeight/(INTERNAL_DIV/16);
          if(selRect){ const {x,y,w,h}=selRect;
            taps.forEach((t,i)=>{
              const pos=t.measure*INTERNAL_DIV+t.time;
              const cy=canvas.height-pos*px;
              const cx=t.lane*laneW+laneW*0.1;
              if(intersects(x,y,w,h,cx,cy-laneHeight*0.2,laneW*0.8,laneHeight*0.4)) selectedTaps.push(i);
            });
            longNotes.forEach((ln,i)=>{
              const s=ln.startMeasure*INTERNAL_DIV+ln.startUnit;
              const e=ln.endMeasure*INTERNAL_DIV+ln.endUnit;
              const y2=canvas.height-e*px;
              const h2=((ln.startMeasure*INTERNAL_DIV+ln.startUnit) - (ln.endMeasure*INTERNAL_DIV+ln.endUnit)) * px * -1;
              const x2=ln.lane*laneW+laneW*0.1;
              if(intersects(x,y,w,h,x2,y2,laneW*0.8,h2)) selectedLong.push(i);
            });
            ticks.forEach((t,i)=>{
              const pos=t.measure*INTERNAL_DIV+t.time;
              const cy=canvas.height-pos*px;
              const cx=t.lane*laneW+laneW*0.1;
              if(intersects(x,y,w,h,cx,cy-laneHeight*0.2,laneW*0.8,laneHeight*0.4)) selectedTicks.push(i);
            });
          }
          selRect=null; draw(); updateActionButtons();
        }
        if(mode==='tick' && e.button===0){ isTickPainting = false; }
      });

      canvas.addEventListener('click',e=>{
        const coord=getCanvasCoords(e);
        const raw=(canvas.height-coord.y)/(laneHeight/(INTERNAL_DIV/16));
        const gu=snap(raw);
        const m=Math.floor(gu/INTERNAL_DIV), u=gu%INTERNAL_DIV;
        const lane=Math.floor(coord.x/(canvas.width/laneCount));

        if(mode==='select' && (clipTaps.length||clipLong.length||clipTicks.length)){
          pasteTarget=m*INTERNAL_DIV+u; updateActionButtons();
        }
        if(mode==='tap'){
          taps.push({measure:m,lane,time:u}); draw();
        } else if(mode==='long'){
          if(pendingLong===null) pendingLong={m,u,lane};
          else{
             const start = pendingLong.m * INTERNAL_DIV + pendingLong.u;
    const end   = m * INTERNAL_DIV + u;
    const dur   = end - start;

    if (dur <= 0) {
      // 同じ位置や、始点より上（時間的に前）をクリックした場合は不可
      alert('終点は始点より下（時間的に後）にしてください');
    } else {
      // 4分未満でも許可
      longNotes.push({
        startMeasure: pendingLong.m,
        startUnit:    pendingLong.u,
        lane:         pendingLong.lane,
        endMeasure:   m,
        endUnit:      u
      });
    }
    pendingLong = null;
    draw();
          }
        }
      });

      canvas.addEventListener('contextmenu', e=>{
        if(mode!=='select'){ e.preventDefault(); }
      });

      document.getElementById('exportMidi').addEventListener('click',()=>{
        const track=new Track(); track.setTempo(bpm);
        const ppq=128, tpu=ppq*4/INTERNAL_DIV;
        taps.forEach(t=>{
          track.addEvent(new NoteEvent({
            pitch:['C1','D1','E1','F1'][t.lane],
            duration:'T'+tpu,
            startTick:(t.measure*INTERNAL_DIV+t.time)*tpu
          }));
        });
        longNotes.forEach(ln=>{
          const st=(ln.startMeasure*INTERNAL_DIV+ln.startUnit)*tpu;
          const du=((ln.endMeasure*INTERNAL_DIV+ln.endUnit)-(ln.startMeasure*INTERNAL_DIV+ln.startUnit))*tpu;
          track.addEvent(new NoteEvent({
            pitch:['C2','D2','E2','F2'][ln.lane],
            duration:'T'+du,
            startTick:st
          }));
        });
        ticks.forEach(t=>{
          track.addEvent(new NoteEvent({
            pitch:['C3','D3','E3','F3'][t.lane],
            duration:'T'+tpu,
            startTick:(t.measure*INTERNAL_DIV+t.time)*tpu
          }));
        });
        const writer=new Writer([track]);
        const b=writer.buildFile();
        const blob=new Blob([new Uint8Array(b)],{type:'audio/midi'});
        const a=document.createElement('a');
        a.href=URL.createObjectURL(blob);
        a.download='chart.mid';
        a.click();
      });

      document.getElementById('importMidi').addEventListener('change', async e=>{
        const file = e.target.files[0]; if(!file) return;
        const buf = await file.arrayBuffer(); 
        const midi = new Midi(buf);

        taps.length = 0; longNotes.length = 0; ticks.length = 0;

        let newBpm = 120;
        if (midi.header && Array.isArray(midi.header.tempos) && midi.header.tempos.length > 0) {
          newBpm = Math.round(midi.header.tempos[0].bpm);
        }
        bpm = newBpm; document.getElementById('bpm').value = bpm;

        const ppq = midi.header?.ppq || 480;
        const tpu = ppq * 4 / INTERNAL_DIV;

        let maxTick = 0;
        midi.tracks.forEach(track=>{
          track.notes.forEach(n=>{
            const name = n.name?.charAt(0);
            const lane = ['C','D','E','F'].indexOf(name);
            if (lane < 0) return;
            const oct = parseInt(n.name?.slice(1));
            if (Number.isNaN(oct)) return;

            const totalUnits = Math.round(n.ticks / tpu);
            const m = Math.floor(totalUnits / INTERNAL_DIV);
            const u = totalUnits % INTERNAL_DIV;

            if (oct === 1){
              taps.push({measure:m,lane,time:u});
              maxTick = Math.max(maxTick, n.ticks);
            } else if (oct === 2){
              const durUnits = Math.round(n.durationTicks / tpu);
              const endTotalUnits = totalUnits + durUnits;
              longNotes.push({
                startMeasure:m, startUnit:u, lane,
                endMeasure:Math.floor(endTotalUnits/INTERNAL_DIV),
                endUnit:endTotalUnits%INTERNAL_DIV
              });
              maxTick = Math.max(maxTick, n.ticks + n.durationTicks);
            } else if (oct === 3){
              ticks.push({measure:m,lane,time:u});
              maxTick = Math.max(maxTick, n.ticks);
            }
          });
        });

        const totalUnits = Math.round(maxTick / tpu);
        measureCount = Math.max(1, Math.ceil(totalUnits / INTERNAL_DIV));
        document.getElementById('measureCount').value = measureCount;

        draw();
        selectedTaps=[]; selectedLong=[]; selectedTicks=[];
        pasteTarget=null; updateActionButtons();
      });

      draw(); updateActionButtons();
    });
  </script>
</body>
</html>
